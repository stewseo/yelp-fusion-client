plugins {
    id 'java-library'
    id 'checkstyle'
    id 'jacoco'
    id 'idea'
    id 'com.github.dawnwords.jacoco.badge'
    id 'com.github.spotbugs'
}

//import java.text.SimpleDateFormat

version = file("../config/version.txt").text.trim()

spotbugs {
    excludeFilter.set(file("../config/spotbugs_filter.xml"))
}

java {
    sourceCompatibility = "17"
    targetCompatibility = "17"
}

ext {

    // json
    jacksonVersion = "2.12.3"
    jakartaVersion = '2.0.1'
    jakartaJsonBindVersion = '2.0.0'
    parssonVersion = '1.0.0'

    // commons
    commonscodecVersion = '1.11'
    commonsioVersion = '2.4'
    commonsloggingVersion = '1.2'

    // http components
    httpasyncclientVersion = '4.1.5'
    httpcoreVersion = '4.4.12'
    httpclientVersion = '4.5.10'

    // logging
    slf4jVersion = '2.0.4'
    logbackVersion = '1.4.1'

    // testing
    jUnitVersion = "5.9.0"
    assertJVersion = "3.23.1"
}

repositories {
    mavenCentral()
}

dependencies {

    api("commons-io:commons-io:${commonsioVersion}")
    api("commons-codec:commons-codec:${commonscodecVersion}")

    // apache http components
    api "org.apache.httpcomponents:httpclient:${httpclientVersion}"
    api "org.apache.httpcomponents:httpcore:${httpcoreVersion}"
    api "org.apache.httpcomponents:httpasyncclient:${httpasyncclientVersion}"
    api "org.apache.httpcomponents:httpcore-nio:${httpcoreVersion}"

    api("org.slf4j:slf4j-api:${slf4jVersion}")

    api("ch.qos.logback:logback-classic:${logbackVersion}")

    api("org.slf4j:jcl-over-slf4j:${slf4jVersion}")

    configurations.all {
        exclude group: "commons-logging", module: "commons-logging"
    }

    testImplementation 'org.assertj:assertj-core:3.23.1'
    testImplementation "org.junit.jupiter:junit-jupiter-api:${jUnitVersion}"
    testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:${jUnitVersion}"
}

// No Warnings
checkstyle {
    config = resources.text.fromString(com.example.CheckstyleUtil.getCheckstyleConfig("/checkstyle.xml"))
    maxWarnings = 0
}

// Enable deprecation messages when compiling Java code
tasks.withType(JavaCompile).configureEach {
    options.compilerArgs << "-Xlint:deprecation"
}

task sourcesJar(type: Jar) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

task javadocJar(type: Jar) {
    classifier = 'javadoc'
    from javadoc
}

javadoc {
    source = sourceSets.main.allJava
}

jacoco {
    toolVersion = "0.8.8"
    reportsDirectory = layout.buildDirectory.dir('customJacocoReportDir')
}

jacocoTestReport {
    reports {
        html.outputLocation = layout.buildDirectory.dir('jacocoHtml')
    }
    dependsOn test // tests are required to run before generating the report
}

//task versionTxt()  {
//    doLast {
//        new File(rootProjectDir, "/config/version.txt").text = """
//Version: $version
//Revision: ${grgit.head().abbreviatedId}
//Buildtime: ${new SimpleDateFormat("dd-MM-yyyy HH:mm:ss").format(new Date())}
//Application-name: yelp-fusion-client
//"""
//    }
//}

//// Do not generate reports for individual projects
//tasks.named("jacocoTestReport") {
//    enabled = false
//}
//
//// Share sources output folder with other projects for aggregated JaCoCo reports
//configurations.create('transitiveSourceOutputsElements') {
//    visible = false
//    canBeResolved = false
//    canBeConsumed = true
//    extendsFrom(configurations.implementation)
//    attributes {
//        attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
//        attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
//        attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'source-output-folders'))
//    }
//    // Use main.output if you have groovy, scala or kotlin other than java in your project
//    sourceSets.main.output.classesDirs.forEach {
//        outgoing.artifact(it)
//    }
//}
//
//// Share sources folder with other projects for aggregated JaCoCo reports
//configurations.create('transitiveSourcesElements') {
//    visible = false
//    canBeResolved = false
//    canBeConsumed = true
//    extendsFrom(configurations.implementation)
//    attributes {
//        attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
//        attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
//        attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'source-folders'))
//    }
//    sourceSets.main.output.classesDirs.forEach {
//        outgoing.artifact(it)
//    }
//}
//
//// Share the coverage data to be aggregated for the whole product
//configurations.create('coverageDataElements') {
//    visible = false
//    canBeResolved = false
//    canBeConsumed = true
//    extendsFrom(configurations.implementation)
//    attributes {
//        attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
//        attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
//        attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jacoco-coverage-data'))
//    }
//    // This will cause the test task to run if the coverage data is requested by the aggregation task
//    outgoing.artifact(tasks.named("test").map { task ->
//        task.extensions.getByType(JacocoTaskExtension).destinationFile
//    })
//}
//
//jacocoBadgeGenSetting {
//    jacocoReportPath  "$buildDir/customJacocoReportDir/test/jacocoTestReport.xml"
//    readmePath "../README.md"
//    // since v0.2.0, percentage limitation (0-100) for different type of coverage
//    limit = ['instruction': 0, 'branch': 0, 'line': 0, 'method': 0, 'class': 0]
//}
